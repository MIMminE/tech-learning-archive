## Broker

`클러스터 (Cluster)` : 여러 대의 서버(노드)가 하나의 시스템처럼 동작하도록 구성된 컴퓨터 그룹을 의미한다. 주로 `확장성`, `가용성`, `신뢰성`을 높이기 위해 사용된다.

`브로커 (Broker)` : 카프카 클러스터 내에서 데이터를 저장하고 관리하며, `프로듀서`와 `컨슈머` 간의 메시지를 중개하는 역할을 한다. 카프카 서버 자체를 의미하기도 한다.

`토픽 (Topic)` : 메시지가 저장되는 논리적 이름으로 여러 개의 `파티션`으로 구성된다.
하나의 카프카 브로커에는 여러 토픽이 존재할 수 있으며, `RDBMS` 의 테이블과 같은 역할이다.

`파티션 (Partition)` : 토픽 내에서 `메시지`를 저장하는 실제 단위이며, 토픽에 메시지가 전달되면
어떤 파티션에 저장할 지에 대한 정책에 따라 순차적으로 각 파티션에 저장되며 이는 로그 파일과 유사하다.
카프카 병렬 처리와 분산 처리를 가능하게 하는 핵심 요소이다.

`메시지 (Message)` : 키와 값으로 구성되며 파티션에 저장되는 각각의 데이터를 가리킨다.
`시리얼라이저`를 통해 다양한 타입을 지원하여 브로커에는 바이트 타입으로 저장된다.

`오프셋 (Offset)` : 각 파티션 내에서 메시지의 순서를 나타내는 고유한 번호이다.
오프셋이 작을 수록 해당 파티션 내 과거의 메시지를 의미한다.

### 토픽과 파티션의 관계

토픽의 파티션 개수 설정을 3으로 할 경우, 토픽 로그를 관리하는 브로커 측 패키지에는 `{토픽 이름}-{파티션 번호}`로 로그 파일을 구별하여 관리하는데, 이는 각 파티션을 별개의 로그 파일로 인식한다는 것이다.
이 파티션은 하나의 브로커에 모두 저장될 수도 있지만 클러스터 내 다른 브로커에 분산 저장될 수 있으며, 각 파티션에 대한 메시지 송수신을 병렬적으로 처리할 수 있다.

클러스터 규모를 확장하여 더 많은 파티션을 분산 배치함으로써 성능을 높일 수 있다. 이러한 개념은 카프카의 확장성과 분산 처리에 핵심이 된다.

### 카프카의 분산 관리

파티션을 여러 브로커에 걸쳐 분산으로 관리하는 방식에는 큰 문제점이 있다. 만약 일부 브로커가 문제가 발생한다면 전체 클러스터의 데이터 정합성이 깨질 것이다.
카프카는 `레플리카셋` 을 사용하여 각 파티션의 복제본을 다른 브로커에 백업하는 방식을 사용하여 위와 같은 문제에 대응한다.

파티션의 데이터를 여러 브로커에 복제하는 저장하는 방식으로 기본적으로 1개의 `리더 파티션`과 N개의 `팔로워 파티션`이 존재한다.
프로듀서에게 데이터를 직접 받는 쪽을 리더 파티션이라 하며, 리더 파티션의 데이터를 동기화하여 백업용으로 존재하는 파티션들을 팔로워 파티션이라 한다.

토픽의 메타 정보에 포함되어 있는 개념 중 `ISR(In-Sync Replica)`는 리더와 동기화 상태를 유지하고 있는 팔로워 집합을 말하며, 리더 파티션이 포함된 브로커가
장애가 발생하면 ISR 중 하나가 새로운 리더로 승격되어 전체 시스템의 데이터 정합성이 깨지지 않도록 한다.

```text
레플리카 개수를 지정할 떄는 클러스터에 속한 노드 개수에 주의해야 한다.
노드의 개수보다 많은 수의 리더 + 팔로워 파티션을 지정할 수 없다.
```

### 분산 환경에서의 내결함성

분산 시스템에서 `내결합성(Fault Tolerance)`은 장애가 발생해도 시스템이 정상적으로 동작하거나 최소한의 성능 저하로 복구할 수 있는 능력을 말한다.
카프카는 `레플리카를 통한 데이터 복제`, `장애 발생 시 ISR 중 새로운 리더 선출`, `ISR 그룹의 동기화 상태 유지` 를 통해 내결함성을 보장한다.

### 파티션과 오프셋

파티션에 들어온 메시지들은 순차적으로 오프셋 값을 가지며, 한번 저장되면 변경할 수 없다. 토픽의 모든 파티션들은 서로 독립적이므로 어떤 파티션이 먼저 들어온 메시지인지 알 수 없다.
파티션 내의 데이터들은 오프셋 값을 통해 시간 순서로 정렬이 가능하다.

이러한 특성을 활용하는 방식으로, 하나의 주체(키)가 발생시키는 모든 이벤트(값)을 하나의 파티션으로만 보내도록 하여 적어도 해당 주체가 발생시킨 이벤트의 순서는 보장받을 수 있다.

### 파티션과 프로듀서 관계

여러 프로듀서가 하나의 파티션에게 메시지를 전송하는 것은 허용된다. 다만 두 프로듀서가 전송하는 메시지의 순서는 보장되지 않는다. 
프로듀서가 파티션으로 메시지를 전송할 때는 `직렬화(Serialize)` 과정을 거쳐 반드시 `Byte Array`로 보내야 한다. 

### 파티션과 컨슈머 관계

동일한 컨슈머 그룹 내에서는 파티션 하나당 반드시 하나의 컨슈머만 할당되어야 한다. 하지만 컨슈머 그룹이 다를 경우에는 허용된다. 
파티션에서 컨슈머로 데이터를 가져올 때는 `Byte Array`를 받아서 `역직렬화(Deserialize)` 과정을 거쳐 원래 형태로 변환해주어야 한다.

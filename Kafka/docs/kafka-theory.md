# Kafka Theory

--- 



## Producer

`프로듀서(Producer)`는 브로커 내의 특정 토픽으로 메시지를 전송하는 역할을 수행하며, 메시지를 어떤 브로커의 파티션으로 보낼지 전략적으로 결정한다.
이 전략적이라는 부분은 현재 카프카 클러스터의 성능, 로드 밸런싱, 가용성, 업무 정합성 등을 고려한다.

### 프로듀서의 메시지 배치(batch) 단위 전송

프로듀서는 브로커에게 메시지를 전송할 때 네트워크 효율성을 높이고 처리량을 극대화하기 위해 메시지를 배치 단위로 전송한다.
카프카 프로듀서 설정 중 이 배치에 관련된 설정값이 존재하며 이를 조절하여 커스텀할 수 있다.

```properties
# 각 파티션에 대해 프로듀서가 한 번에 전송할 수 있는 최대 배치 바이트 크기, 기본값은 16KB 이다.
batch.size=16384
# 각 단위 배치를 채우기 위한 최대 대기 시간을 설정한다. 기본값은 0이다.
# 배치가 가득차지 않아도 해당 시간이 지나면 메시지가 전송된다.
# 네트워크 효율성을 올릴 수 있지만 대기 시간이 길어지면 전송 지연이 증가할 수 있다.
linger.ms=5
# 메시지 전송하기 전에 배치를 압축할지 여부를 설정한다. 기본값은 none 으로 압축을 사용하지 않는다.
# 압축은 CPU 리소스를 사용하므로 요구사항에 따라 결정한다.
compression.type=gzip
# 프로듀서가 전송할 수 있는 최대 메시지 바이트 크기를 지정한다. 기본값은 1MB 이다.
# 이 값은 개별 메시지와 배치 전체 크기에 적용된다.
# 이 값은 브로커 설정 message.max.bytes, replica.fetch.max.bytes 설정과 연관이 있다.
max.request.size=2097152
```

`batch.size`와 `max.request.size`는 모두 메시지 전송과 관련된 크기를 제어하며 다음과 같은 관계를 가지고 있다.

- 배치 크기는 요청 크기보다 작거나 같아야 한다.
- 만약 단일 메시지가 배치 크기보다 크면 해당 메시지는 배치로 묶이지 않고 단독으로 전송된다.
- 단일 메시지 크기가 요청 크기보다 크면 전송에 실패한다.

네트워크 효율성 측면에서 배치 크기를 너무 작게 하면 네트워크 호출이 너무 많아지고, 너무 크게 설정하면 요청 크기 제한을 넘어가거나 전송 지연이 발생할 수 있다.

### 토픽 기반 메시지 전송

카프카 토픽은 여러 파티션으로 구성되어져 있으며, 이 파티션들은 보통 서로 다른 브로커에게 분배되어 있다.
이는 카프카의 가용성, 병렬성 등과 연관이 있는데 파티션들을 서로 다른 브로커에게 할당함으로써 하나의 브로커에 문제가 발생했을 떄를 대비할 수 있다.

- 프로듀서는 토픽으로 메시지를 전송할 때 배치 단위로 각 파티션들에게 보내게 되는데, 어떤 배치에 메시지를 적재하는지는 상황과 전략에 따라 결정된다.
- 보통 배치는 프로듀서가 전송하기 위한 토픽의 파티션 수와 일치하며 프로듀서는 내부에 `파티셔너`의 결정에 각 파티션으로 가게될 배치에 메시지를 적재한다.
- 어떤 파티션으로 보낼지를 정하는 것을 `파티션 선택 전략`이라고 하며, 키가 없는 메시지와 키가 있는 메시지를 나누어서 보통 따로 따로 전략을 적용한다.

`키가 없는 메시지` : 라운드 로빈 방식(Round Robin) 또는 스티키 파티션(Sticky Partition) 방식을 사용한다. 키가 없는 메시지들은 메시지가 들어오는 대로 배치에 순차적으로 들어가게 된다.

- 라운드 로빈 : 들어오는 메시지를 순서대로 배치 공간에 하나씩 적재한다. 배치는 자신에게 설정된 최대 크기 또는 최대 대기 시간 등의 설정에 따라 전송된다.
- 스티키 파티션 방식 : 배치들을 빠르게 가득채워서 보내는 목적으로 메시지를 적재한다. 라운드 로빈 방식의 낮은 네트워크 효율성을 해결하기 위해 사용되며 기본값이다.

`키가 있는 메시지` : 키를 기반으로 특정 파티션을 선택하는 방식을 사용한다. 모듈러 연산 해싱 알고리즘을 통해 키를 파티션 번호로 계산한다.
이는 동일한 키를 가진 메시지는 항상 동일한 파티션으로 가는 것을 보장하며 동일 키를 가지는 메시지간의 순서를 보장할 수 있다.

### 프로듀서의 acks 옵션

프로듀서가 브로커에 메시지를 전송한 후, 브로커로부터 응답을 기다리는 방식을 정의하는 옵션이다. 메시지가 브로커에게 제대로 전송이 되었는지를 확인하는 방식으로 `신뢰성`과 `성능`간의 균형을 결정하는 요소이다.

| `acks` 값   | 신뢰성 수준 | 성능    | 데이터 손실 가능성    | 설명                              |
|------------|--------|-------|---------------|---------------------------------|
| `acks=0`   | 낮음     | 매우 빠름 | 높음            | 브로커로부터 응답을 받지 않음                |
| `acks=1`   | 중간     | 빠름    | 리더 장애 시 손실 가능 | 리더 파티션에 성공적으로 기록되면 응답을 보냄       |
| `acks=all` | 높음     | 느림    | 거의 없음         | 리더와 모든 ISR 에 성공적으로 기록된 후 응답을 보냄 |

---

## Consumer

컨슈머는 브로커에서 데이터를 읽어오는 역할을 하며, 보통 하나 이상의 컨슈머들을 하나의 그룹으로 만들어 하나의 토픽과 매핑한다. 이때 동일한 컨슈머 그룹에 속한
컨슈머들은 같은 토픽의 개별 파티션에 하나씩 고유하게 할당되며, 하나의 컨슈머 그룹은 하나의 비즈니스 데이터 병렬 처리 단위라고 보기도 한다.
- 하나의 파티션은 반드시 컨슈머 그룹 내에서 단 하나의 컨슈머에게만 할당된다.
- 컨슈머 그룹에 속한 컨슈머 수가 파티션 수보다 많으면 일부 컨슈머는 데이터를 읽지 않는다.
- 파티션 수가 컨슈머 수보다 많은 여러 파티션을 하나의 컨슈머가 처리한다. 
- 컨슈머 그룹 이름은 카프카 `브로커의 오프셋 관리`의 기준이 된다.

### 컨슈머 그룹에 대한 오프셋 관리
동일한 컨슈머 그룹에 속한 컨슈머들은 공유된 오프셋을 사용하여 다른 컨슈머에 의해 소모된 오프셋을 받지않도록 설계되어 있다.
여기서 소모된 오프셋이라 함은 다른 컨슈머가 이미 사용하여 commit 처리를 한 오프셋을 말한다.

서로 다른 컨슈머 그룹이 동일한 토픽을 읽더라도 각자의 오프셋을 별도로 관리하며 컨슈머에 설정된 `auto.offset.reset` 값에 따라
파티션에 적재된 처음 메시지부터 전부 받을지(`earliest`), 가장 마지막 오프셋부터 읽을지(`latest`) 결정하게 된다. 

카프카는 컨슈머 그룹별 오프셋을 독립적으로 관리하며 내부 관리용 토픽 `__consumer_offsets` 에 의해 관리된다.
- 컨슈머 그룹 groupA가 토픽 TopicA 메시지를 소비하려고 할 때, 이전에 오프셋 커밋 기록이 있다면 브로커는 해당 오프셋부터 컨슈머 그룹에 전달한다.
- 커밋된 오프셋이 없다면 컨슈머 그룹의 `auto.offset.reset` 설정에 따라 메시지를 읽을 위치를 결정한다.


### 컨슈머의 subscribe, poll, commit 로직
컨슈머는 subscribe, poll, commit 세 가지 주요 메서드를 사용하여 브로커와 상호작용하며 다음과 같은 역할을 담당한다.
- `subscribe` : 컨슈머가 읽고자하는 토픽을 구독한다. 
- `poll` : 구독한 토픽의 파티션에서 데이터를 가져온다. 여러 개의 메시지를 가져오며, 주기적으로 호출되지 않으면 브로커가 해당 컨슈머의 세션을 만료시킨다.
- `commit` : 컨슈머가 처리한 메시지의 오프셋을 커밋하여 다음에 어디서부터 읽어야 할지를 브로커에게 알린다.

컨슈머는 자신의 구성 정보 중 auto.offset.reset 값을 참조하여 자신에게 처음 연결된 특정 파티션의 데이터를 어디서부터 읽을지 결정한다.



### 
## Introduction

실제 어플리케이션에서는 저수준의 스레드 객체를 직접 관리하는 대신, `Executor Service`와 같은 고수준 동시성 프레임워크를 사용하는 것이 일반적이다.
Executor Service 는 복잡한 스레드 생성과 재사용을 신경 쓰지 않고도 효율적으로 여러 작업을 병렬로 처리할 수 있도록 도와준다.

기존의 플랫폼 스레드를 사용하는 상황에서는 `Executor Service`의 스레드 재사용은 스레드 풀 기술을 사용하는 측면으로 사용되었다.
여러 플랫폼 스레드를 미리 만들어둔 다음에 필요할 떄 재사용하는 방식인데, 이러한 방식은 가상 스레드에는 적용되기 어렵다. 
가상 스레드는 일회성 작업에 적합한, 사용하고 버리는 객체로 취급해야 한다.

플랫폼 스레드만 존재하던 시기에는 Executor Service 를 단순하게 스레드 풀이라고 생각하기 쉽고 그렇게 생각해도 크게 문제될 것은 없었지만
가상 스레드 개념이 도입된 지금에는 이를 `스레드 관리를 위한 추상화된 개념`이라고 생각하는 것이 좋다.

## Executor Service Types
일반적으로 사용되는 Executor Service 타입에는 다음과 같은 것들이 있다.
- `Fixed Thread Pool` : 정해진 개수의 스레드로 구성된 풀이다. 
- `Single Thread Executor` : 하나의 워커 스레드만 가지며, 하나씩 순차적으로 처리해야 할 때 유용하다.
- `Cached Thread Pool` : 탄력적인 방식으로 사용량에 따라서 스레드 개수를 조절하는 스레드 풀이다. 보통 1분 이상 사용되지 않는 스레드는 폐기된다. 
- `Scheduled Thread Pool` : 특정 간격마다 작업을 실행하도록 설계된 스레드 풀이다.

submit 메서드를 통해 Callable, Runnable 타입을 전달할 수 있으며, 작업을 제출할 때마다 내부의 작업 큐에 추가되고 작업 큐가 비어있지 않으면
스레드들이 큐에서 작업을 하나씩 가져가 실행하고 결과를 반환하는 방식으로 동작한다.

자바 21부터는 `Thread Per Task Executor` 라는 새로운 구현체를 제공하며, 이는 작업마다 새로운 스레드를 필요에 따라 생성한다.
기존에 사용되던 구현체들과는 달리 내부에 작업 큐가 없으며 작업이 들어올 때마다 새로운 가상 스레드를 만들어 작업을 수행하고 결과를 반환한다.

## Auto Closeable
자바 21부터는 Executor Service 가 `AutoCloseable` 를 상속하도록 변경되었으며, 그로인해 `try-with-resources` 구문 사용이 가능해졌다. 
기존에는 수동으로 shutdown 또는 shutdownNow 메서드를 호출하여 수동으로 리소스를 반환해주어야 했다.

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public static void main(String[] args) {

    try (ExecutorService executor = Executors.newSingleThreadExecutor()) {
        executor.submit(()-> System.out.println("runnable task!"));
    }
}
```
try 구문을 빠져나올때 자동으로 shutdown 메서드가 호출되면서 자원을 정리한다. 
하지만 반드시 try-with-resources 방식을 사용해야만 하는 것은 아니다. 이 방식은 코드상에서 try 블록이 종료되는 시점에 자원을 반환하므로
웹 서버와 같이 종료시점이 명확하지 않는 곳에서는 프로그램 종료 시점에 자원을 정리하도록 수동으로 shutdown를 해주는 것이 더 올바르다.

## Executor Service Types - 실습
```java
private static void execute(ExecutorService executor, int taskCount) {
    try (executor) {
        for (int i = 0; i < taskCount; i++) {
            int j = i;
            executor.submit(() -> ioTask(j));
        }
    }
}
```
ExecutorService 구현체와 ioTask 횟수를 전달받아 작업을 전달하는 실습 코드이다. 여기에 여러 타입의 ExecutorService 구현체를 전달하여 차이를 확인한다.

```java
public static void main(String[] args) {
    execute(Executors.newSingleThreadExecutor(), 3);
    execute(Executors.newFixedThreadPool(2), 3);
    execute(Executors.newCachedThreadPool(), 3);

    execute(Executors.newVirtualThreadPerTaskExecutor(), 3);
}
```
- `SingleThreadExecutor` : 3개의 작업이 병렬성 없이 순차적으로 실행된다.
- `FixedThreadPool` : 2개의 스레드에서 병렬적으로 실행된다. 작업의 개수가 더 많으므로 마지막 작업은 앞의 작업이 끝날 떄까지 대기한다.
- `CachedThreadPool` : 처음에는 스레드가 하나도 없지만 작업이 들어오는 만큼 스레드가 추가되어 결국 모든 작업이 병렬로 실행된다.
- `VirtualThreadPerTaskExecutor` : 작업이 들어올때마다 가상 스레드를 생성하여 처리한다. 항상 병렬로 처리된다.

## External Service 
실제 외부 서비스로부터 IO 통신을 하는 환경을 만들기 위해 샘플 외부 마이크로서비스를 구동시키고 실습에 활용한다.
기본 7070 포트를 사용하여 구동되는 단순한 Rest API를 제공하는 마이크로서비스이다. 

## External Service Client

sss
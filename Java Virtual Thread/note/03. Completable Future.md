## Introduction

CompletableFuture 는 자바 8에서 비동기 및 동시성 프로그래밍을 위해 도입된 도구로, 비동기 작업의 오류를 처리하고 결과를 결합하는 데 깔끔하고 표현력 있는 방식을 제공한다.
IO 작업 시 ForkJoinPool을 사용하고 Executor를 직접 지정하는 것도 제공하며 자바 21부터는 가상 스레드 Executor 를 지정할 수 있게되었다.

CompletableFuture 가 사용되는 이유에는 다음과 같은 것들이 있다.

- 복잡한 비동기 요구사항을 선언적으로 표현할 수 있다. 여러 작업의 병렬 실행, 결과 결합, 예외 및 타임아웃 처리 등을 체이닝 방식으로 작성할 수 있다.
- 실제 서비스에서는 비동기 호출과 예외 처리가 섞인 복잡한 흐름이 자주 등장하기에, 명확한 표현에서 코드의 가독성이 좋다.

### 리액티브 프로그래밍과의 차이점

리액티브 프로그래밍은 데이터의 흐름과 변화(이벤트, 신호 등)에 반응하는 프로그래밍 패러다임으로,
비동기 스트림(Observable/Publisher)과 그에 대한 구독 모델을 사용해 연속적인 데이터 흐름에 대한 복잡한 이벤트 파이프라인에 특화되어 있다.

CompletableFuture 는 미래의 하나의 결과(또는 예외)가 비동기로 준비되는 상황에 적합한 도구이다. 예로 외부 API 호출, 데이터베이스 쿼리 등 여러 작업이 동시에
이뤄지더라도 이것들을 조합하여 하나의 값을 다룬다는 것이다.

비동기로 처리되는 것은 두 방식이 동일하지만 여러 값이나 이벤트 스트림을 결과로 처리한다는 것에서 차이가 있다.

## How CompletableFuture Works

전통적인 동기식 블로킹 스타일 프로그래밍에서는 하나의 메서드가 또 다른 메서드를 호출하고, 호출당한 메서드는 작업을 완료하고 결과를 직접 반환한다.
이때 작업이 완료될때까지 호출한 메서드 측면에서 블로킹이 발생한다.

CompletableFuture 방식은 하나의 메서드가 또 다른 메서드를 호출하자마자 CompletableFuture 객체를 반환받는다. 또 다른 메서드의 작업은 다른 스레드에서 
수행되고 작업이 끝나면 반환했던 CompletableFuture 객체에 결과를 담는다. (어떤 데이터를 담는 이러한 역할의 객체를 플레이스 홀더라 함)
이러한 방식은 호출하는 메서드의 동작 시간이 길거나 외부와의 통신이 필요하여 호출자의 블로킹이 발생할 수 있는 상황에서 유용하게 사용된다.

`CompletableFuture`의 이점에는 다음과 같은 것들이 있다.
- 논블로킹 실행 : 호출 메서드가 결과를 기다리며 블로킹되지 않는다.
- 병렬 처리 : 여러 작업을 동싱체 실행이 가능하다.
- 파이프라인 구성 : 작업 완료 후 다음 작업을 연결하는 체이닝 방식으로 실행이 가능하다.
- 예외 처리 : 비동기 작업의 예외를 효과적으로 처리가 가능하다.

## Simple CompletableFuture Demo

```java
import java.util.concurrent.CompletableFuture;

private static CompletableFuture<String> fastTask(){
    var cf = new CompletableFuture<String>();
    cf.complete("Hi");
    return cf;
}
// ...
var cf = fastTask();
// cf.get(); 
```
CompletableFuture 를 사용하여 빠르게 완료되는 작업을 처리할 때는 전통적인 방식의 메서드 반환 방식을 쓰는 것과 큰 차이가 없다.
get, join 등의 메서드는 CompletableFuture 객체 상자에 결과가 들어와 있을 떄까지 블로킹되어 대기하거나 결과를 가져올 때 사용하는 메서드이다.

CompletableFuture 를 활용하기 좋은 사례는 IO 작업이나 CPU 작업 등에 의해 어느정도 시간 소요가 예상될 떄이다.

```java
import java.time.Duration;
import java.util.concurrent.CompletableFuture;

private static CompletableFuture<String> slowTask() {
    var cf = new CompletableFuture<String>();
    Thread.ofVirtual().start(() -> {
        CommonUtils.sleep(Duration.ofSeconds(1));
        cf.complete("Hi");
    });
}

// slowTask().thenAccept(v -> log.info("value = {}", v));
```
CompletableFuture 객체 자체는 결과를 담는 컨테이너 역할만을 할 뿐 실제 작업의 실행을 자동으로 해주지는 않는다. 때문에 프로덕션에서는
주로 thenAccept, thenApply, thenCompose 등의 콜백 메서드들과 함께 사용되는게 일반적이다. 

이때, cf 객체 내부의 작업이 완료되었는지 여부에 따라 콜백으로 주어진 작업의 실행 스레드가 결정되곤 한다. 예를 들어, 이전 단계(cf 객체의 결과가 반환된 것을 의미)가 완료된 상태라면
현재 스레드에서 콜백 작업이 실행되고 그렇지 않으면 이전 단계를 완료한 스레드에서 실행된다. 

예제에서 보면 slowTask 메서드를 실행할 때, 내부에서 가상 스레드를 생성하여 cf 작업 결과를 complete 해주고 있다. thenAccept 같은 메서드를 쓰지 않아도 작업이 실행되고 cf 결과를 받아볼 수 있었던 것은
가상 스레드를 내부에서 실행시켜주고 있기 때문이다. 

CompletableFuture 에서 상황에 따라 별도의 스레드에서 작업을 수행해야할 때, 기본적으로 ForkJoinPool 를 사용하며 명시적으로 다른 스레드 풀을 지정할 수 있다. 
단, 가상 스레드 풀은 지정하지 않는 것이 좋다. 가상 스레드는 재사용에 적합한 스레드가 아님을 명심하자.








## Run Async

## Supply Async

## Getting Product Info